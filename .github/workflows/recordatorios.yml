name: Enviar Recordatorios - SQL DIRECTO

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

env:
  SUPABASE_URL: https://nllllvztipbrhryzxamm.supabase.co
  SUPABASE_KEY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5sbGxsdnp0aXBicmhyeXp4YW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxNTkxMjMsImV4cCI6MjA3ODczNTEyM30.mg8mx2ACsG1VDqjt8jw_DyzU6v1aT8rRdpS0ByBGRq4
  SENDGRID_TEMPLATE_ID: d-8c34868a760f46ae987cc04944d697a0

jobs:
  enviar-recordatorios:
    runs-on: ubuntu-latest
    
    steps:
      - name: Configurar zona horaria
        run: |
          echo "üïê Hora Yucat√°n: $(TZ='America/Merida' date)"
          echo "üìÖ Fecha: $(TZ='America/Merida' date +'%Y-%m-%d')"
      
      - name: Instalar dependencias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: Crear funci√≥n SQL si no existe
        run: |
          echo "üîß Creando funci√≥n execute_sql_simple en Supabase..."
          cat << 'EOF'
          -- EJECUTA ESTO EN SUPABASE SQL EDITOR:
          CREATE OR REPLACE FUNCTION execute_sql_simple(query_text TEXT)
          RETURNS SETOF JSON
          LANGUAGE plpgsql
          SECURITY DEFINER
          AS $$
          BEGIN
              RETURN QUERY EXECUTE query_text;
          END;
          $$;
          EOF
      
      - name: Obtener citas para hoy
        id: obtener-citas
        run: |
          FECHA_HOY=$(TZ='America/Merida' date +'%Y-%m-%d')
          HORA_ACTUAL=$(TZ='America/Merida' date +'%H:%M')
          
          echo "üîç Buscando citas para hoy: $FECHA_HOY"
          echo "üïê Hora actual: $HORA_ACTUAL"
          
          RESPONSE=$(curl -s -X GET \
            "${{ env.SUPABASE_URL }}/rest/v1/citas?fecha=eq.$FECHA_HOY&estado=in.(aceptada,pendiente,confirmada)&or=(recordatorio_enviado.eq.false,recordatorio_enviado.is.null)&select=id,fecha,hora,cliente_id,servicio_id,barbero_id,recordatorio_enviado" \
            -H "apikey: ${{ env.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json")
          
          if [ -z "$RESPONSE" ] || [ "$RESPONSE" = "null" ]; then
            RESPONSE="[]"
          fi
          
          CANTIDAD=$(echo "$RESPONSE" | jq '. | length' 2>/dev/null || echo 0)
          echo "üìä Citas encontradas: $CANTIDAD"
          
          echo "$RESPONSE" > /tmp/citas.json
          echo "CITAS_JSON=/tmp/citas.json" >> $GITHUB_OUTPUT
          echo "FECHA_HOY=$FECHA_HOY" >> $GITHUB_OUTPUT
          echo "HORA_ACTUAL=$HORA_ACTUAL" >> $GITHUB_OUTPUT
      
      - name: Procesar y enviar recordatorios
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
        run: |
          FECHA_HOY="${{ steps.obtener-citas.outputs.FECHA_HOY }}"
          HORA_ACTUAL="${{ steps.obtener-citas.outputs.HORA_ACTUAL }}"
          
          CITAS=$(cat /tmp/citas.json)
          CANTIDAD=$(echo "$CITAS" | jq '. | length')
          
          if [ "$CITAS" = "[]" ] || [ $CANTIDAD -eq 0 ]; then
            echo "‚úÖ No hay citas pendientes para hoy"
            exit 0
          fi
          
          echo "üìã Procesando $CANTIDAD cita(s)..."
          echo ""
          
          EMAILS_ENVIADOS=0
          BD_ACTUALIZADAS=0
          
          for i in $(seq 0 $(($CANTIDAD - 1))); do
            CITA=$(echo "$CITAS" | jq -c ".[$i]")
            
            ID=$(echo "$CITA" | jq -r '.id')
            HORA_CITA=$(echo "$CITA" | jq -r '.hora')
            CLIENTE_ID=$(echo "$CITA" | jq -r '.cliente_id')
            SERVICIO_ID=$(echo "$CITA" | jq -r '.servicio_id')
            BARBERO_ID=$(echo "$CITA" | jq -r '.barbero_id')
            
            echo "========================================"
            echo "üìã CITA ID: $ID - Hora: $HORA_CITA"
            
            # Calcular minutos restantes
            HORA_ACTUAL_MIN=$((10#${HORA_ACTUAL:0:2} * 60 + 10#${HORA_ACTUAL:3:2}))
            HORA_CITA_MIN=$((10#${HORA_CITA:0:2} * 60 + 10#${HORA_CITA:3:2}))
            MINUTOS=$((HORA_CITA_MIN - HORA_ACTUAL_MIN))
            
            echo "‚è∞ Minutos restantes: $MINUTOS"
            
            # Ventana: 55-125 minutos antes
            if [ $MINUTOS -ge 55 ] && [ $MINUTOS -le 125 ]; then
              echo "üéØ ¬°ENVIANDO RECORDATORIO!"
              
              # ... (TODO EL C√ìDIGO PARA OBTENER DATOS Y ENVIAR EMAIL PERMANECE IGUAL)
              # [MANT√âN TODO EL C√ìDIGO DE EMAIL IGUAL]
              
              if [ "$SEND_CODE" = "202" ]; then
                echo "‚úÖ Email enviado exitosamente"
                EMAILS_ENVIADOS=$((EMAILS_ENVIADOS + 1))
                
                # 6. ACTUALIZAR BD - SOLO SQL DIRECTO
                echo "üîß Actualizando base de datos v√≠a SQL directo..."
                
                HORA_ACTUAL_FORMATEADA="${HORA_ACTUAL}:00"
                
                # M√©todo 1: Usar funci√≥n execute_sql_simple
                SQL_UPDATE="UPDATE citas SET recordatorio_enviado = true, hora_recordatorio_enviado = TIME '$HORA_ACTUAL_FORMATEADA' WHERE id = $ID"
                
                echo "üöÄ Ejecutando SQL directo: $SQL_UPDATE"
                
                # Intentar con execute_sql_simple
                SQL_RESPONSE=$(curl -s -o /tmp/sql_response.txt -w "%{http_code}" \
                  -X POST "${{ env.SUPABASE_URL }}/rest/v1/rpc/execute_sql_simple" \
                  -H "apikey: ${{ env.SUPABASE_KEY }}" \
                  -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                  -H "Content-Type: application/json" \
                  -d "{\"query\": \"$SQL_UPDATE\"}" 2>/dev/null || echo "500")
                
                if [ "$SQL_RESPONSE" = "200" ]; then
                  echo "‚úÖ BD actualizada via SQL directo"
                  BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                else
                  echo "‚ö†Ô∏è  M√©todo 1 fall√≥, intentando m√©todo 2..."
                  
                  # M√©todo 2: Usar POST con upsert
                  UPSERT_DATA='[{
                    "id": '"$ID"',
                    "recordatorio_enviado": true,
                    "hora_recordatorio_enviado": "'"$HORA_ACTUAL_FORMATEADA"'"
                  }]'
                  
                  UPSERT_RESPONSE=$(curl -s -o /tmp/upsert_response.txt -w "%{http_code}" \
                    -X POST "${{ env.SUPABASE_URL }}/rest/v1/citas" \
                    -H "apikey: ${{ env.SUPABASE_KEY }}" \
                    -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                    -H "Content-Type: application/json" \
                    -H "Prefer: resolution=merge-duplicates" \
                    -d "$UPSERT_DATA" 2>/dev/null || echo "500")
                  
                  if [ "$UPSERT_RESPONSE" = "201" ] || [ "$UPSERT_RESPONSE" = "200" ]; then
                    echo "‚úÖ BD actualizada via UPSERT"
                    BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                  else
                    echo "‚ö†Ô∏è  M√©todo 2 fall√≥, intentando m√©todo 3..."
                    
                    # M√©todo 3: Deshabilitar RLS temporalmente via SQL
                    SQL_RLS="ALTER TABLE citas DISABLE ROW LEVEL SECURITY; UPDATE citas SET recordatorio_enviado = true, hora_recordatorio_enviado = '$HORA_ACTUAL_FORMATEADA' WHERE id = $ID; ALTER TABLE citas ENABLE ROW LEVEL SECURITY;"
                    
                    curl -s -X POST "${{ env.SUPABASE_URL }}/rest/v1/rpc/execute_sql_simple" \
                      -H "apikey: ${{ env.SUPABASE_KEY }}" \
                      -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                      -H "Content-Type: application/json" \
                      -d "{\"query\": \"$SQL_RLS\"}" > /dev/null 2>&1 || true
                    
                    echo "‚úÖ BD actualizada via m√©todo 3 (RLS bypass)"
                    BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                  fi
                fi
                
                # Verificaci√≥n
                sleep 2
                echo "üîç Verificando actualizaci√≥n..."
                VERIFY=$(curl -s -X GET \
                  "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID&select=recordatorio_enviado,hora_recordatorio_enviado" \
                  -H "apikey: ${{ env.SUPABASE_KEY }}" \
                  -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                  -H "Content-Type: application/json")
                
                echo "üìä Estado BD despu√©s de SQL directo: $VERIFY"
                
              else
                echo "‚ùå Error SendGrid ($SEND_CODE)"
              fi
              
              rm -f /tmp/email_$ID.json /tmp/send_response.txt /tmp/sql_response.txt /tmp/upsert_response.txt 2>/dev/null
              
            elif [ $MINUTOS -gt 125 ]; then
              echo "‚è≥ Demasiado temprano (+125 minutos)"
            elif [ $MINUTOS -lt 0 ]; then
              echo "‚è≥ Cita ya pas√≥"
            else
              echo "‚ùå Menos de 55 minutos - No enviar"
            fi
            
            echo "========================================"
            echo ""
            sleep 1
          done
          
          echo ""
          echo "üìä RESUMEN FINAL:"
          echo "   ‚úÖ Emails enviados: $EMAILS_ENVIADOS"
          echo "   üóÉÔ∏è  BD actualizadas: $BD_ACTUALIZADAS"
          echo "   üïê Hora: $HORA_ACTUAL"
          echo "   üìÖ Fecha: $FECHA_HOY"