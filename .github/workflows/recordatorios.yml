name: Enviar Recordatorios de Citas

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

env:
  SUPABASE_URL: https://nllllvztipbrhryzxamm.supabase.co
  SUPABASE_KEY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5sbGxsdnp0aXBicmhyeXp4YW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxNTkxMjMsImV4cCI6MjA3ODczNTEyM30.mg8mx2ACsG1VDqjt8jw_DyzU6v1aT8rRdpS0ByBGRq4
  SENDGRID_TEMPLATE_ID: d-8c34868a760f46ae987cc04944d697a0

jobs:
  enviar-recordatorios:
    runs-on: ubuntu-latest
    
    steps:
      - name: Configurar zona horaria
        run: |
          echo "üïê Hora Yucat√°n: $(TZ='America/Merida' date)"
          echo "üìÖ Fecha: $(TZ='America/Merida' date +'%Y-%m-%d')"
      
      - name: Instalar dependencias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: Obtener citas para hoy
        id: obtener-citas
        run: |
          FECHA_HOY=$(TZ='America/Merida' date +'%Y-%m-%d')
          HORA_ACTUAL=$(TZ='America/Merida' date +'%H:%M')
          
          echo "üîç Buscando citas para: $FECHA_HOY"
          echo "üïê Hora actual: $HORA_ACTUAL"
          
          RESPONSE=$(curl -s -X GET \
            "${{ env.SUPABASE_URL }}/rest/v1/citas?fecha=eq.$FECHA_HOY&estado=in.(aceptada,pendiente,confirmada)&recordatorio_enviado=eq.false&select=id,fecha,hora,cliente_id,servicio_id,barbero_id" \
            -H "apikey: ${{ env.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json")
          
          # FIX: Asegurar que la respuesta sea un array JSON v√°lido
          if [ -z "$RESPONSE" ] || [ "$RESPONSE" = "null" ]; then
            RESPONSE="[]"
          fi
          
          # Validar JSON y limpiar si es necesario
          if echo "$RESPONSE" | jq empty 2>/dev/null; then
            # JSON v√°lido, contar citas
            CANTIDAD=$(echo "$RESPONSE" | jq '. | length')
            echo "üìä Citas encontradas: $CANTIDAD"
            
            # Guardar en archivo temporal para evitar problemas con caracteres especiales
            echo "$RESPONSE" > /tmp/citas.json
            
            # SOLUCI√ìN: Guardar solo la fecha y hora en outputs
            # y el JSON en un archivo que pueda ser le√≠do en el siguiente step
            echo "CITAS_JSON=/tmp/citas.json" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  JSON inv√°lido, usando array vac√≠o"
            echo "[]" > /tmp/citas.json
            echo "CITAS_JSON=/tmp/citas.json" >> $GITHUB_OUTPUT
            echo "üìä Citas encontradas: 0"
          fi
          
          # Guardar solo valores simples en outputs
          echo "FECHA_HOY=$FECHA_HOY" >> $GITHUB_OUTPUT
          echo "HORA_ACTUAL=$HORA_ACTUAL" >> $GITHUB_OUTPUT
          
          # Debug: mostrar el JSON que obtenemos
          echo "üîç JSON obtenido (primeros 500 chars):"
          echo "$RESPONSE" | head -c 500
          echo ""
      
      - name: Procesar y enviar recordatorios
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
        run: |
          FECHA_HOY="${{ steps.obtener-citas.outputs.FECHA_HOY }}"
          HORA_ACTUAL="${{ steps.obtener-citas.outputs.HORA_ACTUAL }}"
          CITAS_JSON_FILE="${{ steps.obtener-citas.outputs.CITAS_JSON }}"
          
          # Leer el JSON desde el archivo
          if [ -f "$CITAS_JSON_FILE" ]; then
            CITAS_JSON=$(cat "$CITAS_JSON_FILE")
          else
            CITAS_JSON="[]"
            echo "‚ö†Ô∏è  No se encontr√≥ archivo de citas, usando array vac√≠o"
          fi
          
          # Debug: Mostrar qu√© recibimos
          echo "üîç DEBUG - Recibido CITAS_JSON:"
          echo "$CITAS_JSON" | head -c 300
          echo "..."
          echo "üîç Longitud: $(echo "$CITAS_JSON" | jq '. | length' 2>/dev/null || echo 'inv√°lido')"
          
          if [ "$CITAS_JSON" = "[]" ] || [ -z "$CITAS_JSON" ] || [ "$CITAS_JSON" = "null" ]; then
            echo "‚ÑπÔ∏è  No hay citas para procesar hoy ($FECHA_HOY)"
            exit 0
          fi
          
          # Verificar si es JSON v√°lido
          if ! echo "$CITAS_JSON" | jq empty 2>/dev/null; then
            echo "‚ùå ERROR: JSON inv√°lido recibido"
            echo "Contenido (primeros 200 chars): $(echo "$CITAS_JSON" | head -c 200)"
            echo "Intentando reparar JSON..."
            
            # Intentar limpiar el JSON
            CITAS_JSON=$(echo "$CITAS_JSON" | sed 's/^[^{[]*\[/[/' | sed 's/[^}\]]*$//')
            
            if echo "$CITAS_JSON" | jq empty 2>/dev/null; then
              echo "‚úÖ JSON reparado exitosamente"
            else
              echo "‚ùå No se pudo reparar el JSON, usando array vac√≠o"
              CITAS_JSON="[]"
            fi
          fi
          
          if [ "$CITAS_JSON" = "[]" ]; then
            echo "‚ÑπÔ∏è  No hay citas para procesar despu√©s de validaci√≥n"
            exit 0
          fi
          
          echo "üìã Procesando citas encontradas..."
          
          # Funci√≥n para crear JSON de SendGrid
          crear_json_sendgrid() {
            local EMAIL="$1"
            local NOMBRE="$2"
            local SERVICIO="$3"
            local FECHA="$4"
            local HORA="$5"
            local BARBERO="$6"
            local MINUTOS="$7"
            local DURACION="$8"
            
            # Escapar caracteres especiales
            local NOMBRE_ESC=$(echo "$NOMBRE" | jq -R . | sed 's/^"//;s/"$//')
            local SERVICIO_ESC=$(echo "$SERVICIO" | jq -R . | sed 's/^"//;s/"$//')
            local FECHA_ESC=$(echo "$FECHA" | jq -R . | sed 's/^"//;s/"$//')
            local BARBERO_ESC=$(echo "$BARBERO" | jq -R . | sed 's/^"//;s/"$//')
            local DURACION_ESC=$(echo "$DURACION" | jq -R . | sed 's/^"//;s/"$//')
            
            # Construir JSON usando jq para asegurar formato v√°lido
            jq -n \
              --arg email "$EMAIL" \
              --arg nombre "$NOMBRE_ESC" \
              --arg servicio "$SERVICIO_ESC" \
              --arg fecha "$FECHA_ESC" \
              --arg hora "$HORA" \
              --arg barbero "$BARBERO_ESC" \
              --argjson minutos "$MINUTOS" \
              --arg duracion "$DURACION_ESC" \
              --arg template_id "${{ env.SENDGRID_TEMPLATE_ID }}" \
            '{
              "personalizations": [{
                "to": [{"email": $email, "name": $nombre}],
                "dynamic_template_data": {
                  "cliente_nombre": $nombre,
                  "servicio_nombre": $servicio,
                  "fecha_cita": $fecha,
                  "hora_cita": $hora,
                  "barbero_nombre": $barbero,
                  "direccion_barberia": "Calle 24-A, Tzucacab, Yucat√°n",
                  "google_maps_link": "https://maps.google.com/?q=20.063818,-89.0476701",
                  "minutos_restantes": $minutos,
                  "duracion_servicio": $duracion,
                  "mensaje_recordatorio": "‚è∞ Recordatorio: Tu cita es dentro de \($minutos) minutos"
                },
                "subject": "‚è∞ Recordatorio de Cita - Waldos Barber-Shop"
              }],
              "from": {"email": "carlosffcastillo57@gmail.com", "name": "Waldos Barber-Shop"},
              "reply_to": {"email": "carlosffcastillo57@gmail.com", "name": "Waldos Barber-Shop"},
              "template_id": $template_id
            }'
          }
          
          # Contador
          EMAILS_ENVIADOS=0
          EMAILS_ERROR=0
          
          # Usar while IFS para procesar cada cita
          while IFS= read -r CITA; do
            if [ -z "$CITA" ]; then
              continue
            fi
            
            ID=$(echo "$CITA" | jq -r '.id // empty')
            HORA_CITA=$(echo "$CITA" | jq -r '.hora // empty')
            CLIENTE_ID=$(echo "$CITA" | jq -r '.cliente_id // empty')
            SERVICIO_ID=$(echo "$CITA" | jq -r '.servicio_id // empty')
            BARBERO_ID=$(echo "$CITA" | jq -r '.barbero_id // empty')
            
            # Validar campos requeridos
            if [ -z "$ID" ] || [ -z "$HORA_CITA" ] || [ -z "$CLIENTE_ID" ]; then
              echo "‚ùå CITA inv√°lida, saltando..."
              continue
            fi
            
            echo ""
            echo "========================================"
            echo "üìã CITA ID: $ID"
            echo "   Hora programada: $HORA_CITA"
            
            # Obtener datos del cliente
            CLIENTE_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/clientes?id=eq.$CLIENTE_ID&select=email,nombre" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            EMAIL=$(echo "$CLIENTE_RESPONSE" | jq -r '.[0].email // empty')
            NOMBRE=$(echo "$CLIENTE_RESPONSE" | jq -r '.[0].nombre // "Cliente"')
            
            if [ -z "$EMAIL" ] || [ "$EMAIL" = "null" ] || [ "$EMAIL" = "" ]; then
              echo "   ‚ùå Email no v√°lido o no encontrado"
              EMAILS_ERROR=$((EMAILS_ERROR + 1))
              continue
            fi
            
            echo "   üë§ Cliente: $NOMBRE"
            echo "   üìß Email: $EMAIL"
            
            # Obtener datos del servicio
            SERVICIO_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/servicios?id=eq.$SERVICIO_ID&select=nombre,duracion" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            SERVICIO_NOMBRE=$(echo "$SERVICIO_RESPONSE" | jq -r '.[0].nombre // "Corte de Cabello"')
            DURACION=$(echo "$SERVICIO_RESPONSE" | jq -r '.[0].duracion // "30 minutos"')
            
            # Obtener datos del barbero
            BARBERO_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/barberos?id=eq.$BARBERO_ID&select=nombre" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            BARBERO_NOMBRE=$(echo "$BARBERO_RESPONSE" | jq -r '.[0].nombre // "Nuestro Barbero"')
            
            # Calcular minutos restantes
            HORA_ACTUAL_MIN=$((10#${HORA_ACTUAL:0:2} * 60 + 10#${HORA_ACTUAL:3:2}))
            HORA_CITA_MIN=$((10#${HORA_CITA:0:2} * 60 + 10#${HORA_CITA:3:2}))
            MINUTOS=$((HORA_CITA_MIN - HORA_ACTUAL_MIN))
            
            echo "   ‚è∞ Minutos restantes: $MINUTOS"
            echo "   üïê Hora actual: $HORA_ACTUAL"
            echo "   üìÖ Fecha hoy: $FECHA_HOY"
            
            # ========== VENTANA AMPLIADA ==========
            # Ventana ideal: 40-120 minutos antes (para asegurar env√≠o)
            
            if [ $MINUTOS -ge 40 ] && [ $MINUTOS -le 120 ]; then
              echo "   üéØ ¬°ENVIANDO RECORDATORIO! (Ventana ampliada: 40-120 min)"
              
              # Formatear fecha bonita
              DIA=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%d')
              MES_NUM=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%m')
              ANIO=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%Y')
              
              case $MES_NUM in
                "01") MES="Enero";; "02") MES="Febrero";; "03") MES="Marzo";;
                "04") MES="Abril";; "05") MES="Mayo";; "06") MES="Junio";;
                "07") MES="Julio";; "08") MES="Agosto";; "09") MES="Septiembre";;
                "10") MES="Octubre";; "11") MES="Noviembre";; "12") MES="Diciembre";;
                *) MES="";;
              esac
              
              FECHA_BONITA="$DIA de $MES de $ANIO"
              
              # Crear JSON usando la funci√≥n con jq
              JSON_DATA=$(crear_json_sendgrid "$EMAIL" "$NOMBRE" "$SERVICIO_NOMBRE" "$FECHA_BONITA" "$HORA_CITA" "$BARBERO_NOMBRE" "$MINUTOS" "$DURACION")
              
              # Guardar JSON a archivo
              echo "$JSON_DATA" > /tmp/sendgrid_$ID.json
              
              # Enviar a SendGrid
              echo "   üì§ Enviando via SendGrid..."
              RESPONSE_CODE=$(curl -s -o /tmp/response_$ID.txt -w "%{http_code}" \
                -X POST "https://api.sendgrid.com/v3/mail/send" \
                -H "Authorization: Bearer $SENDGRID_API_KEY" \
                -H "Content-Type: application/json" \
                -d @/tmp/sendgrid_$ID.json)
              
              if [ "$RESPONSE_CODE" = "202" ]; then
                echo "   ‚úÖ Email enviado exitosamente (C√≥digo: $RESPONSE_CODE)"
                EMAILS_ENVIADOS=$((EMAILS_ENVIADOS + 1))
                
                # Marcar como enviado en Supabase
                curl -s -X PATCH "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID" \
                  -H "apikey: ${{ env.SUPABASE_KEY }}" \
                  -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                  -H "Content-Type: application/json" \
                  -H "Prefer: return=minimal" \
                  -d "{
                    \"recordatorio_enviado\": true,
                    \"hora_recordatorio_enviado\": \"$HORA_ACTUAL\",
                    \"actualizado_en\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"
                  }"
                
                echo "   ‚úÖ Marcada como enviada en BD"
              else
                echo "   ‚ùå Error SendGrid (C√≥digo: $RESPONSE_CODE)"
                EMAILS_ERROR=$((EMAILS_ERROR + 1))
                
                # Mostrar error detallado
                if [ -f "/tmp/response_$ID.txt" ]; then
                  echo "   üîç Detalles del error:"
                  cat /tmp/response_$ID.txt
                fi
              fi
              
              # Limpiar archivos temporales
              rm -f /tmp/sendgrid_$ID.json /tmp/response_$ID.txt 2>/dev/null
              
              # Esperar 1 segundo entre emails para evitar rate limits
              sleep 1
              
            elif [ $MINUTOS -gt 120 ]; then
              echo "   ‚è≥ Demasiado temprano (+2 horas)"
            elif [ $MINUTOS -lt 0 ]; then
              echo "   ‚è≥ La cita ya pas√≥"
              # Marcar como enviado aunque ya pas√≥ para no volver a procesar
              curl -s -X PATCH "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID" \
                -H "apikey: ${{ env.SUPABASE_KEY }}" \
                -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                -H "Prefer: return=minimal" \
                -d "{\"recordatorio_enviado\": true}" > /dev/null 2>&1
            else
              echo "   ‚ùå Muy tarde (menos de 40 minutos)"
            fi
            
            echo "========================================"
            
          done < <(echo "$CITAS_JSON" | jq -c '.[]')
          
          echo ""
          echo "üìä RESUMEN DE EJECUCI√ìN:"
          echo "   ‚úÖ Emails enviados exitosamente: $EMAILS_ENVIADOS"
          echo "   ‚ùå Emails con error: $EMAILS_ERROR"
          echo "   üïê Hora de ejecuci√≥n: $HORA_ACTUAL"
          echo "   üìÖ Fecha procesada: $FECHA_HOY"
          echo "   ‚úâÔ∏è  Remitente: carlosffcastillo57@gmail.com"
          echo "   üé® Template ID: ${{ env.SENDGRID_TEMPLATE_ID }}"
          echo "   ‚è∞ Ventana ampliada: 40-120 minutos antes"
      
      - name: Finalizar
        run: |
          echo ""
          echo "========================================"
          echo "‚úÖ WORKFLOW COMPLETADO"
          echo "========================================"
          echo "üèÅ Finalizado: $(TZ='America/Merida' date)"
          echo "üìç Zona horaria: America/Merida (UTC-6)"
          echo "‚úâÔ∏è  Servicio: SendGrid"
          echo "üè™ Barber√≠a: Waldos Barber-Shop"
          echo "üìß Remitente verificado: carlosffcastillo57@gmail.com"
          echo "‚è∞ Recordatorios: 40-120 minutos antes (ventana ampliada)"
          echo "üîÑ Pr√≥xima ejecuci√≥n: en 5 minutos"
          echo "========================================"