name: Enviar Recordatorios - SOLUCI√ìN DEFINITIVA

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

env:
  SUPABASE_URL: https://nllllvztipbrhryzxamm.supabase.co
  SUPABASE_KEY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5sbGxsdnp0aXBicmhyeXp4YW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxNTkxMjMsImV4cCI6MjA3ODczNTEyM30.mg8mx2ACsG1VDqjt8jw_DyzU6v1aT8rRdpS0ByBGRq4
  SENDGRID_TEMPLATE_ID: d-8c34868a760f46ae987cc04944d697a0

jobs:
  enviar-recordatorios:
    runs-on: ubuntu-latest
    
    steps:
      - name: Configurar zona horaria
        run: |
          echo "üïê Hora Yucat√°n: $(TZ='America/Merida' date)"
          echo "üìÖ Fecha: $(TZ='America/Merida' date +'%Y-%m-%d')"
      
      - name: Instalar dependencias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: Obtener citas para hoy
        id: obtener-citas
        run: |
          FECHA_HOY=$(TZ='America/Merida' date +'%Y-%m-%d')
          HORA_ACTUAL=$(TZ='America/Merida' date +'%H:%M')
          
          echo "üîç Buscando citas para: $FECHA_HOY"
          echo "üïê Hora actual: $HORA_ACTUAL"
          
          # MODIFICADO: Buscar citas con recordatorio_enviado = false O null
          RESPONSE=$(curl -s -X GET \
            "${{ env.SUPABASE_URL }}/rest/v1/citas?fecha=eq.$FECHA_HOY&estado=in.(aceptada,pendiente,confirmada)&recordatorio_enviado=eq.false&select=id,fecha,hora,cliente_id,servicio_id,barbero_id,recordatorio_enviado" \
            -H "apikey: ${{ env.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json")
          
          # Tambi√©n buscar citas con recordatorio_enviado IS NULL
          RESPONSE_NULL=$(curl -s -X GET \
            "${{ env.SUPABASE_URL }}/rest/v1/citas?fecha=eq.$FECHA_HOY&estado=in.(aceptada,pendiente,confirmada)&recordatorio_enviado=is.null&select=id,fecha,hora,cliente_id,servicio_id,barbero_id,recordatorio_enviado" \
            -H "apikey: ${{ env.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json")
          
          # Combinar respuestas
          COMBINED=$(echo "$RESPONSE $RESPONSE_NULL" | jq -s 'add | unique')
          
          if [ -z "$COMBINED" ] || [ "$COMBINED" = "null" ]; then
            COMBINED="[]"
          fi
          
          if echo "$COMBINED" | jq empty 2>/dev/null; then
            CANTIDAD=$(echo "$COMBINED" | jq '. | length')
            echo "üìä Citas encontradas: $CANTIDAD"
            echo "$COMBINED" > /tmp/citas.json
            echo "CITAS_JSON=/tmp/citas.json" >> $GITHUB_OUTPUT
            
            # Mostrar estado actual
            echo "üìã Estado de citas encontradas:"
            echo "$COMBINED" | jq -r '.[] | "  ID \(.id) a las \(.hora): recordatorio_enviado=\(.recordatorio_enviado // "null")"'
          else
            echo "‚ö†Ô∏è  JSON inv√°lido, usando array vac√≠o"
            echo "[]" > /tmp/citas.json
            echo "CITAS_JSON=/tmp/citas.json" >> $GITHUB_OUTPUT
            echo "üìä Citas encontradas: 0"
          fi
          
          echo "FECHA_HOY=$FECHA_HOY" >> $GITHUB_OUTPUT
          echo "HORA_ACTUAL=$HORA_ACTUAL" >> $GITHUB_OUTPUT
      
      - name: Procesar y enviar recordatorios
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
        run: |
          FECHA_HOY="${{ steps.obtener-citas.outputs.FECHA_HOY }}"
          HORA_ACTUAL="${{ steps.obtener-citas.outputs.HORA_ACTUAL }}"
          CITAS_JSON_FILE="${{ steps.obtener-citas.outputs.CITAS_JSON }}"
          
          if [ -f "$CITAS_JSON_FILE" ]; then
            CITAS_JSON=$(cat "$CITAS_JSON_FILE")
          else
            CITAS_JSON="[]"
            echo "‚ö†Ô∏è  No se encontr√≥ archivo de citas, usar array vac√≠o"
          fi
          
          echo "üîç Recibidas $(echo "$CITAS_JSON" | jq '. | length' 2>/dev/null || echo 0) citas"
          
          if [ "$CITAS_JSON" = "[]" ] || [ -z "$CITAS_JSON" ] || [ "$CITAS_JSON" = "null" ]; then
            echo "‚ÑπÔ∏è  No hay citas para procesar hoy ($FECHA_HOY)"
            exit 0
          fi
          
          # Contador
          EMAILS_ENVIADOS=0
          EMAILS_ERROR=0
          BD_ACTUALIZADAS=0
          BD_ERRORES=0
          
          while IFS= read -r CITA; do
            if [ -z "$CITA" ]; then
              continue
            fi
            
            ID=$(echo "$CITA" | jq -r '.id // empty')
            HORA_CITA=$(echo "$CITA" | jq -r '.hora // empty')
            CLIENTE_ID=$(echo "$CITA" | jq -r '.cliente_id // empty')
            SERVICIO_ID=$(echo "$CITA" | jq -r '.servicio_id // empty')
            BARBERO_ID=$(echo "$CITA" | jq -r '.barbero_id // empty')
            ESTADO_ACTUAL=$(echo "$CITA" | jq -r '.recordatorio_enviado // "null"')
            
            if [ -z "$ID" ] || [ -z "$HORA_CITA" ] || [ -z "$CLIENTE_ID" ]; then
              continue
            fi
            
            echo ""
            echo "========================================"
            echo "üìã CITA ID: $ID"
            echo "   Hora programada: $HORA_CITA"
            echo "   Estado actual BD: $ESTADO_ACTUAL"
            
            # Obtener datos del cliente
            CLIENTE_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/clientes?id=eq.$CLIENTE_ID&select=email,nombre,apellido" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            EMAIL=$(echo "$CLIENTE_RESPONSE" | jq -r '.[0].email // empty')
            NOMBRE=$(echo "$CLIENTE_RESPONSE" | jq -r '.[0].nombre // "Cliente"')
            APELLIDO=$(echo "$CLIENTE_RESPONSE" | jq -r '.[0].apellido // ""')
            
            if [ -n "$APELLIDO" ] && [ "$APELLIDO" != "null" ]; then
              NOMBRE_COMPLETO="$NOMBRE $APELLIDO"
            else
              NOMBRE_COMPLETO="$NOMBRE"
            fi
            
            if [ -z "$EMAIL" ] || [ "$EMAIL" = "null" ]; then
              echo "   ‚ùå Email no encontrado"
              EMAILS_ERROR=$((EMAILS_ERROR + 1))
              continue
            fi
            
            echo "   üë§ Cliente: $NOMBRE_COMPLETO"
            echo "   üìß Email: $EMAIL"
            
            # Obtener datos del servicio
            SERVICIO_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/servicios?id=eq.$SERVICIO_ID&select=nombre,duracion" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            SERVICIO_NOMBRE=$(echo "$SERVICIO_RESPONSE" | jq -r '.[0].nombre // "Corte de Cabello"')
            DURACION=$(echo "$SERVICIO_RESPONSE" | jq -r '.[0].duracion // "30 minutos"')
            
            # Obtener datos del barbero
            BARBERO_RESPONSE=$(curl -s -X GET \
              "${{ env.SUPABASE_URL }}/rest/v1/barberos?id=eq.$BARBERO_ID&select=nombre" \
              -H "apikey: ${{ env.SUPABASE_KEY }}" \
              -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
              -H "Content-Type: application/json")
            
            BARBERO_NOMBRE=$(echo "$BARBERO_RESPONSE" | jq -r '.[0].nombre // "Nuestro Barbero"')
            
            # Calcular minutos restantes
            HORA_ACTUAL_MIN=$((10#${HORA_ACTUAL:0:2} * 60 + 10#${HORA_ACTUAL:3:2}))
            HORA_CITA_MIN=$((10#${HORA_CITA:0:2} * 60 + 10#${HORA_CITA:3:2}))
            MINUTOS=$((HORA_CITA_MIN - HORA_ACTUAL_MIN))
            
            echo "   ‚è∞ Minutos restantes: $MINUTOS"
            
            # Ventana ampliada: 40-120 minutos antes
            if [ $MINUTOS -ge 40 ] && [ $MINUTOS -le 120 ]; then
              echo "   üéØ ¬°ENVIANDO RECORDATORIO! (Ventana: 40-120 min)"
              
              # Formatear fecha bonita
              DIA=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%d')
              MES_NUM=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%m')
              ANIO=$(TZ='America/Merida' date -d "$FECHA_HOY" '+%Y')
              
              case $MES_NUM in
                "01") MES="Enero";; "02") MES="Febrero";; "03") MES="Marzo";;
                "04") MES="Abril";; "05") MES="Mayo";; "06") MES="Junio";;
                "07") MES="Julio";; "08") MES="Agosto";; "09") MES="Septiembre";;
                "10") MES="Octubre";; "11") MES="Noviembre";; "12") MES="Diciembre";;
                *) MES="";;
              esac
              
              FECHA_BONITA="$DIA de $MES de $ANIO"
              
              # ============================================
              # 1. ENVIAR EMAIL
              # ============================================
              
              # JSON SIMPLIFICADO
              JSON_DATA='{
                "personalizations": [{
                  "to": [{"email": "'"$EMAIL"'", "name": "'"$NOMBRE_COMPLETO"'"}],
                  "dynamic_template_data": {
                    "cliente_nombre": "'"$NOMBRE_COMPLETO"'",
                    "servicio_nombre": "'"$SERVICIO_NOMBRE"'",
                    "fecha_cita": "'"$FECHA_BONITA"'",
                    "hora_cita": "'"$HORA_CITA"'",
                    "barbero_nombre": "'"$BARBERO_NOMBRE"'",
                    "minutos_restantes": "'"$MINUTOS"'",
                    "duracion_servicio": "'"$DURACION"'"
                  },
                  "subject": "Recordatorio de cita - Waldos Barber-Shop"
                }],
                "from": {
                  "email": "carlosffcastillo57@gmail.com",
                  "name": "Waldos Barber-Shop"
                },
                "template_id": "'"${{ env.SENDGRID_TEMPLATE_ID }}"'"
              }'
              
              echo "$JSON_DATA" > /tmp/sendgrid_$ID.json
              
              echo "   üì® Enviando email..."
              
              RESPONSE_CODE=$(curl -s -o /tmp/response_$ID.txt -w "%{http_code}" \
                -X POST "https://api.sendgrid.com/v3/mail/send" \
                -H "Authorization: Bearer $SENDGRID_API_KEY" \
                -H "Content-Type: application/json" \
                -d @/tmp/sendgrid_$ID.json)
              
              if [ "$RESPONSE_CODE" = "202" ]; then
                echo "   ‚úÖ Email enviado exitosamente"
                EMAILS_ENVIADOS=$((EMAILS_ENVIADOS + 1))
                
                # ============================================
                # 2. ACTUALIZAR BASE DE DATOS - M√âTODO MEJORADO
                # ============================================
                echo "   üîß Actualizando base de datos..."
                
                # TIMESTAMP actual
                TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S")
                
                # **SOLUCI√ìN DEFINITIVA**: Usar formato PostgreSQL correcto
                # Intentar con diferentes m√©todos
                
                # M√âTODO 1: Booleano PostgreSQL (recomendado)
                echo "   üîÑ Intento 1: Formato PostgreSQL booleano..."
                PATCH_DATA1='{"recordatorio_enviado": true, "hora_recordatorio_enviado": "'"$HORA_ACTUAL"'", "actualizado_en": "'"$TIMESTAMP'"}'
                
                echo "   üìä Datos PATCH: $PATCH_DATA1"
                
                PATCH_RESPONSE1=$(curl -v -s -o /tmp/patch1.txt -w "%{http_code}" \
                  -X PATCH "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID" \
                  -H "apikey: ${{ env.SUPABASE_KEY }}" \
                  -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                  -H "Content-Type: application/json" \
                  -H "Prefer: return=representation" \
                  -d "$PATCH_DATA1")
                
                echo "   üì§ Respuesta PATCH (cruda): $PATCH_RESPONSE1"
                
                if [ "$PATCH_RESPONSE1" = "200" ]; then
                  echo "   ‚úÖ PATCH exitoso (200 - with representation)"
                  BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                elif [ "$PATCH_RESPONSE1" = "204" ]; then
                  echo "   ‚úÖ PATCH exitoso (204 - no content)"
                  BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                else
                  echo "   ‚ùå PATCH fall√≥ con c√≥digo $PATCH_RESPONSE1"
                  
                  # M√âTODO 2: Usar raw SQL mediante RPC
                  echo "   üîÑ Intento 2: Usando funci√≥n RPC..."
                  
                  # Primero crear la funci√≥n si no existe
                  echo "   üîß Creando funci√≥n RPC si no existe..."
                  SQL_FUNCTION='CREATE OR REPLACE FUNCTION actualizar_recordatorio(cita_id integer, enviado boolean, hora_envio text)
                  RETURNS void AS $$
                  BEGIN
                    UPDATE citas 
                    SET recordatorio_enviado = enviado, 
                        hora_recordatorio_enviado = hora_envio,
                        actualizado_en = NOW()
                    WHERE id = cita_id;
                  END;
                  $$ LANGUAGE plpgsql;'
                  
                  # Llamar a la funci√≥n
                  RPC_DATA='{"cita_id": '$ID', "enviado": true, "hora_envio": "'"$HORA_ACTUAL"'"}'
                  
                  PATCH_RESPONSE2=$(curl -s -o /tmp/patch2.txt -w "%{http_code}" \
                    -X POST "${{ env.SUPABASE_URL }}/rest/v1/rpc/actualizar_recordatorio" \
                    -H "apikey: ${{ env.SUPABASE_KEY }}" \
                    -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                    -H "Content-Type: application/json" \
                    -d "$RPC_DATA")
                  
                  if [ "$PATCH_RESPONSE2" = "200" ] || [ "$PATCH_RESPONSE2" = "204" ]; then
                    echo "   ‚úÖ RPC exitoso"
                    BD_ACTUALIZADAS=$((BD_ACTUALIZADAS + 1))
                  else
                    echo "   ‚ùå RPC tambi√©n fall√≥"
                    BD_ERRORES=$((BD_ERRORES + 1))
                  fi
                fi
                
                # VERIFICAR FINAL
                echo "   üîç Verificando estado final en BD..."
                sleep 2
                VERIFY_RESPONSE=$(curl -s -X GET \
                  "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID&select=id,recordatorio_enviado,hora_recordatorio_enviado,actualizado_en" \
                  -H "apikey: ${{ env.SUPABASE_KEY }}" \
                  -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                  -H "Content-Type: application/json")
                
                echo "   üìä Estado final: $VERIFY_RESPONSE"
                
              else
                echo "   ‚ùå Error SendGrid (C√≥digo: $RESPONSE_CODE)"
                EMAILS_ERROR=$((EMAILS_ERROR + 1))
              fi
              
              # Limpiar
              rm -f /tmp/sendgrid_$ID.json /tmp/response_$ID.txt /tmp/patch*.txt 2>/dev/null
              sleep 1
              
            elif [ $MINUTOS -gt 120 ]; then
              echo "   ‚è≥ Demasiado temprano (+2 horas)"
            elif [ $MINUTOS -lt 0 ]; then
              echo "   ‚è≥ La cita ya pas√≥ - Marcando como enviada"
              # Forzar actualizaci√≥n
              curl -s -X PATCH "${{ env.SUPABASE_URL }}/rest/v1/citas?id=eq.$ID" \
                -H "apikey: ${{ env.SUPABASE_KEY }}" \
                -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
                -d '{"recordatorio_enviado": true}' > /dev/null 2>&1
            else
              echo "   ‚ùå Muy tarde (menos de 40 minutos)"
            fi
            
            echo "========================================"
            
          done < <(echo "$CITAS_JSON" | jq -c '.[]')
          
          echo ""
          echo "üìä RESUMEN DE EJECUCI√ìN:"
          echo "   ‚úÖ Emails enviados: $EMAILS_ENVIADOS"
          echo "   ‚ùå Emails con error: $EMAILS_ERROR"
          echo "   üóÉÔ∏è  BD actualizadas: $BD_ACTUALIZADAS"
          echo "   ‚ùå BD errores: $BD_ERRORES"
          echo "   üïê Hora: $HORA_ACTUAL"
          echo "   üìÖ Fecha: $FECHA_HOY"
      
      - name: SOLUCI√ìN MANUAL SI TODO FALLA
        run: |
          echo ""
          echo "üîß SOLUCI√ìN MANUAL DEFINITIVA"
          echo "================================"
          echo "SI LA BD SIGUE SIN ACTUALIZARSE, ejecuta estos comandos EN ORDEN:"
          echo ""
          echo "1. Actualizar valores NULL a false:"
          echo "   UPDATE citas SET recordatorio_enviado = false WHERE recordatorio_enviado IS NULL;"
          echo ""
          echo "2. Verificar citas de hoy:"
          echo "   SELECT id, hora, recordatorio_enviado FROM citas WHERE fecha = CURRENT_DATE;"
          echo ""
          echo "3. Forzar actualizaci√≥n manual:"
          echo "   UPDATE citas SET recordatorio_enviado = true, hora_recordatorio_enviado = '15:48' WHERE id = 134;"
          echo ""
          echo "4. Crear trigger para futuro (opcional):"
          echo "   CREATE OR REPLACE FUNCTION set_recordatorio_default()"
          echo "   RETURNS TRIGGER AS $$"
          echo "   BEGIN"
          echo "     IF NEW.recordatorio_enviado IS NULL THEN"
          echo "       NEW.recordatorio_enviado := false;"
          echo "     END IF;"
          echo "     RETURN NEW;"
          echo "   END;"
          echo "   $$ LANGUAGE plpgsql;"
          echo ""
          echo "   CREATE TRIGGER set_recordatorio_default_trigger"
          echo "   BEFORE INSERT OR UPDATE ON citas"
          echo "   FOR EACH ROW"
          echo "   EXECUTE FUNCTION set_recordatorio_default();"
          echo "================================"
      
      - name: Finalizar
        run: |
          echo ""
          echo "========================================"
          echo "‚úÖ WORKFLOW COMPLETADO - SOLUCI√ìN DEFINITIVA"
          echo "========================================"
          echo "üèÅ Finalizado: $(TZ='America/Merida' date)"
          echo "üìä Resultado: $EMAILS_ENVIADOS emails, $BD_ACTUALIZADAS BD actualizadas"
          echo "üîÑ Pr√≥xima ejecuci√≥n: en 5 minutos"
          echo "========================================"